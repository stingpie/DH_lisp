(define null? not)
(define pair? (lambda (x) (eq? (type x) 4)))
(define list? (lambda (x)
    (if (pair? x)
      (list? (next x))
      (not x)
    )
))
(define equal? (lambda (x y)
    (or
      (eq? x y)
      (and 
	(pair? x)
	(pair? y)
	(equal? (first x) (first y))
	(equal? (next x) (next y))
      )
    )
))
( define reduce-forward (lambda (f x t)
  (if t
    (f (first t) (reduce-forward f x (next t)))
    x)
))
(define reduce-backward (lambda (f x t)
  (if t
    (reduce-backward f (f (first t) x) (next t))
    x)
))
(define nthcdr (lambda (t n)
  (if (eq? n 0)
    t
    (nthcdr (next t) (- n 1))
  )
))
(define nth (lambda (t n)
  (first (nthcdr t n))
))
(define filter (lambda (f t)
  (if t
    (if (f (first t))
      (pair (first t) (filter f (next t)))
      (filter f (next t))
    )
    ()
  )
))
(define all? (lambda (f t)
  (if t
    (if (f (first t))
      (all? f (next t))
      ()
    )
    #t
  )
))
(define any? (lambda (f t)
  (if t 
    (if (f (first t))
      #t
      (any? f (next t))
    )
    ()
  )
))
(define curry (lambda (f x) (lambda args ( f x . args))))
(define compose ( lambda (f g) (lambda args (f (g . args)))))
(define mapcar (lambda (f t)
  (if t
    (pair (f (first t)) (mapcar f (next t)))
    ()
  )
))
(define map (lambda (f . args)
  (if (any? null? args)
    ()
    (let*
      (x (mapcar first args))
      (t (mapcar next args))
      (pair (f . x) (map f . t))
    )
  )
))
(define append1 (lambda (s t) 
  (if s
    (pair (first s) (append1 ( next s) t))
    t
  )
))
(define append (lambda (t . args)
  (if args
    (append1 t (append . args))
    t
  )
))
(define zip (lambda args (map list . args)))
(define sublist (lambda (_list start number)
  (cond ((> start 0) 
	 (sublist (next _list) (- start 1) number))
	((> number 0)
	 (pair (first _list) (sublist (next _list) 0 (- number 1))))
  )
))
(define length-tr (lambda (t n)
  (if t
    (length-tr (next t) (+ n 1))
    n
  )
))
(define length (lambda (t) (length-tr t 0)))
(print (env))
(list 1 2 3 4 5 6 7 )
